package com.example.codegen

import com.example.annotation.Serializable
import com.example.codegen.commons.Logger
import com.example.codegen.commons.Primitive
import com.example.codegen.extension.isExtendedBy
import com.example.codegen.extension.isNullablePrimitive
import com.example.codegen.model.ClassBinding
import com.example.codegen.model.FieldBinding
import com.squareup.kotlinpoet.*
import org.json.JSONArray
import org.json.JSONObject
import javax.lang.model.type.DeclaredType
import javax.lang.model.type.TypeKind
import javax.lang.model.type.TypeMirror
import javax.tools.Diagnostic

object CodeGen {

    private var objID = 0   // Unique Object Identifier

    private val JSON_OBJECT_CLASS_NAME = JSONObject::class.asClassName()
    private val JSON_ARRAY_CLASS_NAME = JSONArray::class.asClassName()
    private const val TO_JSON_OBJECT_FUN_NAME = "toJSONObject"

    fun createFileSpec(packageName: String, binding: ClassBinding): FileSpec {
        val builder = FileSpec.builder(packageName, "${binding.getSimpleName()}Stub")
            .addImport(JSON_OBJECT_CLASS_NAME.packageName, JSON_OBJECT_CLASS_NAME.simpleName)
            .addImport(JSON_ARRAY_CLASS_NAME.packageName, JSON_ARRAY_CLASS_NAME.simpleName)
            .addFunction(createToJSONObjectFunc(binding))
            //.addFunction(createToClassObjectFunc(binding))
        return builder.build()
    }

    private fun createToJSONObjectFunc(binding: ClassBinding): FunSpec {
        val builder = FunSpec.builder(TO_JSON_OBJECT_FUN_NAME)
            .addModifiers(KModifier.INTERNAL)
            // Extension functions can be generated by specifying a receiver
            // https://square.github.io/kotlinpoet/#extension-functions
            .receiver(binding.getClassName())
            .returns(JSONObject::class)
            .addStatement("val obj = %L()", JSON_OBJECT_CLASS_NAME.simpleName)
        binding.getFieldBindings().forEach { builder.addCode(createToJSONObjectCodeBlock(it)) }
        builder.addStatement("return obj")
        return builder.build()
    }

    // https://square.github.io/kotlinpoet/#code-control-flow
    // https://square.github.io/kotlinpoet/#code-block-format-strings
    private fun createToJSONObjectCodeBlock(binding: FieldBinding): CodeBlock {
        val builder = CodeBlock.builder()
        if (binding.isPrimitive() || binding.isNullablePrimitive()) {
            builder.addStatement("obj.put(%S, %L)", binding.getKeyName(), binding.getFieldName())
        } else if (binding.isDeclared()) {
            val declaredType = binding.getType() as DeclaredType
            when {
                binding.isExtendedBy(CharSequence::class.java) -> {
                    builder.addStatement("obj.put(%S, %L)", binding.getKeyName(), binding.getFieldName())
                }
                binding.isExtendedBy(Collection::class.java) -> {
                    val elementType = declaredType.typeArguments[0]
                    builder.add(createToJSONObjectCodeBlock(binding, elementType, OuterType.COLLECTION))
                }
                binding.isExtendedBy(Map::class.java) -> {
                    val keyType = declaredType.typeArguments[0]
                    if (!keyType.isExtendedBy(String::class.java)) {
                        ProcessingEnvUtils.printMessage(Diagnostic.Kind.ERROR,
                            "JSON field Map support String key type only",
                            binding.fieldElement)
                    }
                    val valueType = declaredType.typeArguments[1]
                    builder.add(createToJSONObjectCodeBlock(binding, valueType, OuterType.MAP))
                }
                else -> {
                    val annotation = declaredType.asElement().getAnnotation(Serializable::class.java)
                    if (annotation == null) {
                        ProcessingEnvUtils.printMessage(Diagnostic.Kind.ERROR,
                            "Invalid JSON field type provided",
                            binding.fieldElement)
                    }
                    builder.addStatement("obj.put(%S, %L.${TO_JSON_OBJECT_FUN_NAME}())", binding.getKeyName(), binding.getFieldName())
                }
            }
        }
        return builder.build()
    }

    enum class OuterType { COLLECTION, MAP }
    private fun createToJSONObjectCodeBlock(binding: FieldBinding, nestedType: TypeMirror, outerType: OuterType): CodeBlock {

        val builder = CodeBlock.builder()
        if (nestedType.kind.isPrimitive || nestedType.isNullablePrimitive()) {
            builder.addStatement("obj.put(%S, %L)", binding.getKeyName(), binding.getFieldName())
        } else if (nestedType.kind.equals(TypeKind.DECLARED)) {
            when {
                nestedType.isExtendedBy(CharSequence::class.java) -> {
                    builder.addStatement("obj.put(%S, %L)", binding.getKeyName(), binding.getFieldName())
                }
                nestedType.isExtendedBy(Collection::class.java) -> {
                    /*
                    ProcessingEnvUtils.printMessage(Diagnostic.Kind.ERROR,
                        "Doesn't support Nested <Collection>",
                        binding.fieldElement) */
                }
                nestedType.isExtendedBy(Map::class.java) -> {
                    /*
                    ProcessingEnvUtils.printMessage(Diagnostic.Kind.ERROR,
                        "Doesn't support Nested <Map>",
                        binding.fieldElement) */
                }
                else -> {
                    val valueTypeElement = (nestedType as DeclaredType).asElement()
                    val valueAnnotation = valueTypeElement.getAnnotation(Serializable::class.java)
                    if (valueAnnotation == null) {
                        ProcessingEnvUtils.printMessage(Diagnostic.Kind.ERROR,
                            "Nested class <${valueTypeElement.simpleName}> doesn't support @Serializable annotation",
                            binding.fieldElement)
                    }
                    when (outerType) {
                        OuterType.COLLECTION -> builder.add(createToJSONObjectNestedCollectionCodeBlock(binding))
                        OuterType.MAP -> builder.add(createToJSONObjectNestedMapCodeBlock(binding))
                    }
                }
            }
        }
        return builder.build()
    }

    private fun createToJSONObjectNestedMapCodeBlock(binding: FieldBinding): CodeBlock {
        val objName = "obj_${objID ++}"
        val innerObjName = "obj_${objID ++}"
        val builder = CodeBlock.builder()
            .beginControlFlow("if (%L != null)", binding.getFieldName())
            .addStatement("val %L = %L()", objName, JSON_OBJECT_CLASS_NAME.simpleName)
            .beginControlFlow("for (%L in %L)", innerObjName, binding.getFieldName())
            .addStatement("%L.put(%L.key, %L.value?.${TO_JSON_OBJECT_FUN_NAME}())", objName, innerObjName, innerObjName)
            .endControlFlow()
            .addStatement("obj.put(%S, %L)", binding.getKeyName(), objName)
            .endControlFlow()
        return builder.build()
    }

    private fun createToJSONObjectNestedCollectionCodeBlock(binding: FieldBinding): CodeBlock {
        val objName = "obj_${objID ++}"
        val innerObjName = "obj_${objID ++}"
        val builder = CodeBlock.builder()
            .beginControlFlow("if (%L != null)", binding.getFieldName())
            .addStatement("val %L = %L()", objName, JSON_ARRAY_CLASS_NAME.simpleName)
            .beginControlFlow("for (%L in %L)", innerObjName, binding.getFieldName())
            .addStatement("%L.put(%L?.${TO_JSON_OBJECT_FUN_NAME}())", objName, innerObjName)
            .endControlFlow()
            .addStatement("obj.put(%S, %L)", binding.getKeyName(), objName)
            .endControlFlow()
        return builder.build()
    }


    private fun createToClassObjectFunc(binding: ClassBinding): FunSpec {
        val builder = FunSpec.builder("to${binding.getSimpleName()}Object")
            .addModifiers(KModifier.INTERNAL)
            .receiver(String::class)
            .returns(binding.getClassName())
            .addStatement("val obj = %L(this)", JSON_OBJECT_CLASS_NAME.simpleName)
            .addStatement("return %L(", binding.getSimpleName())
        binding.getFieldBindings().forEach { builder.addCode(createToClassObjectCodeBlock(it)) }
        builder.addStatement(")")
        return builder.build()
    }

    private fun createToClassObjectCodeBlock(binding: FieldBinding): CodeBlock {
        val builder = CodeBlock.builder()
        when {
            binding.isPrimitive() -> {
                builder.addStatement("obj.opt(%S).toString().${Primitive(binding.getType()).toTypeFunc(Primitive.Kind.PRIMITIVE)},", binding.getKeyName())
            }
            binding.isNullablePrimitive() -> {
                builder.addStatement("obj.opt(%S)?.toString()?.${Primitive(binding.getType()).toTypeFunc(Primitive.Kind.NULLABLE)},", binding.getKeyName())
            }
            binding.isDeclared() -> {
                val declaredType = binding.getType() as DeclaredType
                when {
                    binding.isExtendedBy(CharSequence::class.java) -> {
                        builder.addStatement("obj.optString(%S, null),", binding.getKeyName())  // String
                    }
                    binding.isExtendedBy(Collection::class.java) -> {

                    }
                    binding.isExtendedBy(Map::class.java) -> {

                    }
                    else -> {
                        val annotation = declaredType.asElement().getAnnotation(Serializable::class.java)
                        if (annotation == null) {
                            ProcessingEnvUtils.printMessage(Diagnostic.Kind.ERROR,
                                "Invalid JSON field type provided",
                                binding.fieldElement)
                        }
                    }
                }
            }
        }
        return builder.build()
    }
}